#:mute

#:if not defined("XDP_SUPPORT")
#:set XDP_SUPPORT = False
#:endif

#:if not defined("QP_SUPPORT")
#:set QP_SUPPORT = False
#:endif

#:if not defined("HP_SUPPORT")
#:set HP_SUPPORT = False
#:endif

#:if not defined("MAXIMUM_RANK")
#:set MAXIMUM_RANK = 2
#:endif

#:set RANK_ITERi  = [(i, None) for i in range(MAXIMUM_RANK + 1)]
#:set RANK_ITERii = [(i, i) for i in range(MAXIMUM_RANK + 1)] + [(i, 0) for i in range(1, MAXIMUM_RANK + 1)]

#:set INTEGER_KINDS = ["INT8", "INT16", "INT32", "INT64"]
#:set INTEGER_POSTFIX = ["i8", "i16", "i32", "i64"]
#:set REAL_KINDS = ["sp", "dp"]
#:set REAL_POSTFIX = ["r32", "r64"]
#:set COMPLEX_POSTFIX = ["c32", "c64"]
#:if XDP_SUPPORT
#:set REAL_KINDS = REAL_KINDS + ["xdp"]
#:set REAL_POSTFIX = REAL_POSTFIX + ["r80"]
#:set COMPLEX_POSTFIX = COMPLEX_POSTFIX + ["c80"]
#:endif
#:if QP_SUPPORT
#:set REAL_KINDS = REAL_KINDS + ["qp"]
#:set REAL_POSTFIX = REAL_POSTFIX + ["r128"]
#:set COMPLEX_POSTFIX = COMPLEX_POSTFIX + ["c128"]
#:endif
#:if HP_SUPPORT
#:set REAL_KINDS = ["hp"] + REAL_KINDS
#:set REAL_POSTFIX = ["r16"] + REAL_POSTFIX
#:set COMPLEX_POSTFIX = ["c16"] + COMPLEX_POSTFIX
#:endif
#:set LOGICAL_KINDS = [""]
#:set LOGICAL_TYPES = ["logical"]
#:set LOGICAL_POSTFIX = ["logical"]

#:set INTEGER_TYPES = [f"integer({k})" for k in INTEGER_KINDS]
#:set REAL_TYPES = [f"real({k})" for k in REAL_KINDS]
#:set COMPLEX_TYPES = [f"complex({k})" for k in REAL_KINDS]
#:set LOGICAL_TYPES = [f"logical"]

#:set INTEGER_KIND_TYPE_POSTS = list(zip(INTEGER_KINDS, INTEGER_TYPES, INTEGER_POSTFIX))
#:set REAL_KIND_TYPE_POSTS = list(zip(REAL_KINDS, REAL_TYPES, REAL_POSTFIX))
#:set COMPLEX_KIND_TYPE_POSTS = list(zip(REAL_KINDS, COMPLEX_TYPES, COMPLEX_POSTFIX))
#:set LOGICAL_KIND_TYPE_POSTS = list(zip(LOGICAL_KINDS, LOGICAL_TYPES, LOGICAL_POSTFIX))

#:def decimal_suffix(i, kind)
$:f"{i}.0_" + kind if "REAL" in kind else f"{i}_" + kind
#:enddef

#:def routine_name(g, post, rank1, rank2=None)
$:f"unittest_{g}_{post}_{rank1}" if rank2 is None else f"unittest_{g}_{post}_{rank1}{rank2}"
#:enddef

#:def rank_suffix(rank)
#{if rank>0}#(${",".join([":" for i in range(rank)])}$)#{endif}#
#:enddef

#:def counter_suffix(rank)
#{if rank>0}#(${", ".join(["i"+str(i+1) for i in range(rank)])}$)#{endif}#
#:enddef

#:def generic_procedure(g, tup, ranks)
#:for rank1, rank2 in ranks
#:for kind, type, post in tup
procedure, private :: ${routine_name(g, post, rank1, rank2)}$
#:endfor
#:endfor
generic            :: ${g}$ => &
${", &\n  ".join([", &\n  ".join(["                      " + routine_name(g, post, rank1, rank2) for kind, type, post in tup]) for rank1, rank2 in ranks])}$
#:enddef

#:def flatten(expr, rank1, rank2=None)
$:f"{expr}" if rank1 == 1 and (rank2 is None or rank2 == 1) else f"[{expr}]"
#:enddef

#:def common_check(rank1, rank2, routine)
$:common_check_1(routine) if rank1>0 and (rank2 is not None and rank2>0) else common_check_0()
#:enddef

#:def common_check_0()
    logical :: err
    this%num_test = this%num_test + 1
#:enddef

#:def common_check_1(routine)
    logical :: err
    this%num_test = this%num_test + 1
    err = ANY(SHAPE(a) /= SHAPE(b))
    if(PRESENT(is_failed)) is_failed = err
    if (err) then
      this%num_error = this%num_error + 1
      call report_rank_error(this%dev, this%num_test, SHAPE(a), SHAPE(b), "${routine}$", unitname)
      return
    end if
#:enddef

#:set L_MSG = 56
#:set L_WDH = L_MSG - 12
#:set WSPC = "REPEAT(' ', 8)"
#:set SEP3 = WSPC + "//REPEAT('-', " + str(L_MSG) + ")"

#:def report_functions()
  subroutine report_rank_error(dev, num_test, size_a, size_b, routine, unitname)
    !! print rank error
    integer, intent(in)                :: dev
    integer, intent(in)                :: num_test
    integer, intent(in)                :: size_a(:)
    integer, intent(in)                :: size_b(:)
    character(*), intent(in)           :: routine
    character(*), intent(in), optional :: unitname
    character(:), allocatable          :: ps
    character(*), parameter            :: WSPC = ${WSPC}$
    character(*), parameter            :: SEP3 = ${SEP3}$
    character(*), parameter            :: rankMissMatch = WSPC//'  Rank MissMatch : '
    integer                            :: ios
    call padd_string(unitname, num_test, routine, '... failed', ${L_WDH}$, ps)
    write (dev, '(I8,A)', IOSTAT=ios) num_test, ps
    write (dev, '(A)', IOSTAT=ios) SEP3
    write (dev, '(2A)', IOSTAT=ios, ADVANCE="NO") rankMissMatch, '['
    write (dev, '(*(I0,:,", "))', IOSTAT=ios, ADVANCE="NO") size_a
    write (dev, '(A)', IOSTAT=ios, ADVANCE="NO") '] /= ['
    write (dev, '(*(I0,:,", "))', IOSTAT=ios, ADVANCE="NO") size_b
    write (dev, '(A)', IOSTAT=ios) ']'
    write (dev, '(A)', IOSTAT=ios) SEP3
  end subroutine report_rank_error
!
  subroutine report_result(dev, num_test, err, routine, unitname)
    !! print test result
    integer, intent(in)                :: dev
    integer, intent(in)                :: num_test
    logical, intent(in)                :: err
    character(*), intent(in)           :: routine
    character(*), intent(in), optional :: unitname
    character(*), parameter            :: SEP3 = ${SEP3}$
    character(:), allocatable          :: ps
    integer                            :: ios
    if (err) then
      call padd_string(unitname, num_test, routine, '... failed', ${L_WDH}$, ps)
      write (dev, '(I8,A)', IOSTAT=ios) num_test, ps
      write (dev, '(A)', IOSTAT=ios) SEP3
    else
      call padd_string(unitname, num_test, routine, '... OK', ${L_WDH}$, ps)
      write (dev, '(I8,A)', IOSTAT=ios) num_test, ps
    end if
  end subroutine report_result
!
  subroutine report_error_rate(dev, n, nerror)
    integer, intent(in)     :: dev, n, nerror
    real(RK)                :: error_rate
    character(*), parameter :: WSPC = ${WSPC}$
    character(*), parameter :: SEP3 = ${SEP3}$
    character(*), parameter :: ErrorRateIs = WSPC//'  Error rate is  : '
    integer                 :: ios
    if (n > 1) then
      error_rate = real(100 * nerror, RK) / real(n, RK)
      write (dev, '(A)', IOSTAT=ios) SEP3
      write (dev, '(A,f7.3,A,I0,A,I0,A)', IOSTAT=ios) &
     &  ErrorRateIs, error_rate, ' %  ( ', nerror, ' / ', n, ' )'
    end if
  end subroutine report_error_rate
!
  pure subroutine padd_string(unitname, ntest, routine, post, nline, res)
    character(*), intent(in), optional       :: unitname
    integer, intent(in)                      :: ntest
    character(*), intent(in)                 :: routine
    character(*), intent(in)                 :: post
    integer, intent(in)                      :: nline
    character(:), allocatable, intent(inout) :: res
    integer                                  :: npad
    if(PRESENT(unitname))then
      npad = MAX(0, nline - LEN_TRIM(unitname))
      res = ' '//TRIM(unitname)//REPEAT(' ', npad)//post
    else
      block
        character(32) :: cntest
        write(cntest, '(I0)') ntest
        npad = MAX(0, nline - LEN(' '//routine//' ') - LEN_TRIM(cntest))
        res = ' '//routine//' '//TRIM(cntest)//REPEAT(' ', npad)//post
      end block
    endif
  end subroutine padd_string
#:enddef

#:def image_functions()
  subroutine report_error_as_image(dev, ndat, nbreak, error_rate)
    integer, intent(in)     :: dev, ndat, nbreak
    real(RK), intent(in)    :: error_rate(ndat)
    character(*), parameter :: SEP3 = ${SEP3}$
    character(*), parameter :: CDIV(21)   = ["165", "129", "093", "057", "021", &
                             &               "020", "019", "018", "017", "016", &
                             &               "000", "052", "088", "124", "160", &
                             &               "196", "202", "208", "214", "220", &
                             &               "226"]
    character(*), parameter :: CSEQ(21)   = ["232", "233", "234", "235", "236", &
                             &               "237", "238", "239", "240", "241", &
                             &               "242", "243", "244", "245", "246", &
                             &               "247", "248", "249", "251", "253", &
                             &               "255"]
    character(*), parameter :: CSEQ_R(21) = ["255", "253", "251", "249", "248", &
                             &               "247", "246", "245", "244", "243", &
                             &               "242", "241", "240", "239", "238", &
                             &               "237", "236", "235", "234", "233", &
                             &               "232"]
    real(RK)                :: mmax
    mmax = MAXVAL(ABS(error_rate))
    if (ALL(error_rate >= 0.0_RK)) then
      call dump_image(dev, ndat, SIZE(CSEQ), nbreak, error_rate, 0.0_RK, mmax, CSEQ)
    elseif (ALL(error_rate <= 0.0_RK)) then
      call dump_image(dev, ndat, SIZE(CSEQ_R), nbreak, error_rate, -mmax, 0.0_RK, CSEQ_R)
    else
      call dump_image(dev, ndat, SIZE(CDIV), nbreak, error_rate, -mmax, mmax, CDIV)
    end if
  end subroutine report_error_as_image
!
  subroutine dump_image(dev, ndat, nmap, nbreak, dat, mmin, mmax, cmap)
    integer, intent(in)       :: dev, ndat, nmap, nbreak
    real(RK), intent(in)      :: dat(ndat), mmin, mmax
    character(*), intent(in)  :: cmap(nmap)
    character(*), parameter   :: ANSI = ACHAR(INT(z'1b'))//"[37m"
    character(*), parameter   :: RESET = ACHAR(INT(z'1b'))//'[m'
    character(:), allocatable :: cb
    integer                   :: i, j, n, ios
    call colorbar(nmap, cmap, cb)
    write (dev, '(2X,G12.3,2A,G12.3)', IOSTAT=ios) mmin, cb, RESET, mmax
    n = MIN(nbreak, ndat)
    write (dev, '(14X, A)', IOSTAT=ios) ANSI//REPEAT("_", n)//RESET
    do i = 1, ndat, nbreak
      n = MIN(i + nbreak - 1, ndat)
      write (dev, '(I5,A,I5, 2X, A)', ADVANCE="NO", IOSTAT=ios) i, " -", n, ANSI
      do j = i, n
        write (dev, '(A)', ADVANCE="NO", IOSTAT=ios) colorpiece(dat(j), mmin, mmax, nmap, cmap)
      end do
      write (dev, '(A)', IOSTAT=ios) RESET
    end do
  end subroutine dump_image
!
  pure function colorpiece(dat, mmin, mmax, nmap, cmap) result(res)
    real(RK), intent(in)     :: dat, mmin, mmax
    integer, intent(in)      :: nmap
    character(*), intent(in) :: cmap(nmap)
    character(*), parameter  :: ANSI = ACHAR(INT(z'1b'))//"[48;5;"
    character(*), parameter  :: CRES = ANSI//"000m_"
    integer, parameter       :: LRES = LEN(CRES)
    character(LRES)          :: res
    integer                  :: k
    if (mmax - mmin < 1.0E-8_RK) then
      k = nmap
    else
      k = NINT((nmap - 1) / (mmax - mmin) * (dat - mmin)) + 1
    end if
    res = ANSI//cmap(k)//"m_"
  end function colorpiece
!
  pure subroutine colorbar(nmap, cmap, res)
    integer, intent(in)       :: nmap
    character(*), intent(in)  :: cmap(nmap)
    character(:), allocatable, intent(inout) :: res
    character(*), parameter   :: ANSI = ACHAR(INT(z'1b'))//"[37;48;5;"
    integer                   :: i
    res = ""
    do i = 1, nmap
      res = res//ANSI//cmap(i)//"m__"
    end do
  end subroutine colorbar
#:enddef

#:endmute
