#:include "common.fypp"
module mod_unittest
  !! Fortran unit testing framework.
  !  This module provides an interface class to the assert method.
  use, intrinsic :: ISO_FORTRAN_ENV, only: STDOUT => OUTPUT_UNIT, &
                  &                        STDERR => ERROR_UNIT, &
                  &                        RK => REAL64
  use mod_unittest_kinds
  implicit none
  private
  public  :: unittest
  public  :: error_stop
!
  character(*), parameter :: SEP1 = "# "//REPEAT('-', 62)
  character(*), parameter :: SEP2 = "# "//REPEAT('=', 62)
!
  type timestamp
    sequence
    integer(INT64) :: time
    real(RK)       :: ctime
  end type timestamp
!
  type test_result
    sequence
    integer :: id
    logical :: err
  end type test_result
!
  type unittest
    private
    integer                        :: dev
    integer                        :: verbose
    integer                        :: dump_line_limit
    character(:), allocatable      :: script_name
    character(:), allocatable      :: tap_string
    type(test_result), allocatable :: results(:)
    type(timestamp), allocatable   :: times(:)
    logical                        :: terminate_with_error_code = .true.
    logical                        :: tap_support = .true.
  contains
    procedure         :: init => utest_init
#:for routine in ["assert", "assert_true", "assert_false"]
${generic_procedure(routine, LOGICAL_KIND_TYPE_POSTS, RANK_ITERi)}$
#:endfor
#:for routine in ["assert_equal", "assert_not_equal"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + LOGICAL_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
#:for routine in ["assert_almost_equal", "assert_not_almost_equal"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
#:for routine in ["assert_less", "assert_less_equal", "assert_greater", "assert_greater_equal"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
#:for routine in ["assert_is_eye", "assert_isnot_eye"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, [(2, None)])}$
#:endfor
#:for routine in ["assert_is_symmetric", "assert_isnot_symmetric"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, [(2, None)])}$
#:endfor
#:for routine in ["assert_is_zero", "assert_isnot_zero"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, RANK_ITERi)}$
#:endfor
#:for routine in ["assert_allclose", "assert_not_allclose"]
${generic_procedure(routine, REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
    procedure         :: finish => utest_finish
    procedure         :: finish_and_terminate => utest_finish_and_terminate
    final             :: utest_destroy
  end type unittest
!
  interface unittest
    module procedure :: utest_new
  end interface unittest
!
  interface
    module subroutine error_stop(msg, code)
      character(*), intent(in), optional :: msg
      integer, intent(in), optional      :: code
    end subroutine error_stop
!
#:for routine, cond in zip(["assert", "assert_true", "assert_false"], ["ALL(expr)", "ALL(expr)", ".not.ANY(expr)"])
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERi
    module subroutine ${routine_name(routine, post, rank1)}$ (this, expr, unitname, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: expr${rank_suffix(rank1)}$
      character(*), intent(in), optional :: unitname
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_equal", "assert_not_equal"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + LOGICAL_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERii
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$, b${rank_suffix(rank2)}$
      character(*), intent(in), optional :: unitname
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_almost_equal", "assert_not_almost_equal"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERii
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$, b${rank_suffix(rank2)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:for routine, cond in zip(["assert_less", "assert_less_equal", "assert_greater", "assert_greater_equal"], ["ALL(a<b)", "ALL(a<=b)", "ALL(a>b)", "ALL(a>=b)"])
#:for rank1, rank2 in RANK_ITERii
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$
      ${type}$, intent(in)               :: b${rank_suffix(rank2)}$
      character(*), intent(in), optional :: unitname
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_is_eye", "assert_isnot_eye"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
    module subroutine ${routine_name(routine, post, 2)}$ (this, a, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(2)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, 2)}$
!
#:endfor
#:endfor
#:for routine in ["assert_is_symmetric", "assert_isnot_symmetric"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
    module subroutine ${routine_name(routine, post, 2)}$ (this, a, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(2)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, 2)}$
!
#:endfor
#:endfor
#:for routine in ["assert_is_zero", "assert_isnot_zero"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERi
    module subroutine ${routine_name(routine, post, rank1)}$ (this, a, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_allclose", "assert_not_allclose"]
#:for kind, type, post in REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERii
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, is_failed, rtol, atol)
      class(unittest), intent(inout)       :: this
      ${type}$, intent(in)                 :: a${rank_suffix(rank1)}$
      ${type}$, intent(in)                 :: b${rank_suffix(rank2)}$
      character(*), intent(in), optional   :: unitname
      logical, intent(out), optional       :: is_failed
      real(${kind}$), intent(in), optional :: rtol
      real(${kind}$), intent(in), optional :: atol
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
  end interface
!
contains
!
  function utest_new(section, terminate_with_error_code, dump_line_limit, tap_support, argparse) result(res)
    character(*), intent(in), optional :: section
    logical, intent(in), optional      :: terminate_with_error_code
    integer, intent(in), optional      :: dump_line_limit
    logical, intent(in), optional      :: tap_support
    logical, intent(in), optional      :: argparse
    type(unittest)                     :: res
    call utest_init(res, section, terminate_with_error_code, dump_line_limit, tap_support, argparse)
  end function utest_new
!
  subroutine utest_init(this, section, terminate_with_error_code, dump_line_limit, tap_support, argparse)
    class(unittest), intent(inout)     :: this
    character(*), intent(in), optional :: section
    logical, intent(in), optional      :: terminate_with_error_code
    integer, intent(in), optional      :: dump_line_limit
    logical, intent(in), optional      :: tap_support
    logical, intent(in), optional      :: argparse
!
    this%terminate_with_error_code = .true.
    this%tap_support = .true.
    this%dump_line_limit = 10
    this%dev = STDERR
!
    if (PRESENT(terminate_with_error_code)) this%terminate_with_error_code = terminate_with_error_code
    if (PRESENT(tap_support)) then
      this%dump_line_limit = 0
      this%tap_support = tap_support
    end if
    if (PRESENT(dump_line_limit)) this%dump_line_limit = dump_line_limit
    this%verbose = MERGE(1, 0, this%dump_line_limit < 0)
!
    if (.not. ALLOCATED(this%script_name)) then
      block
        integer                   :: lna, ios
        character(:), allocatable :: tmp
        call GET_COMMAND_ARGUMENT(0, length=lna, status=ios)
        if (ios /= 0) return
        allocate (character(0) :: this%script_name)
        allocate (character(lna) :: tmp)
        call GET_COMMAND_ARGUMENT(0, value=tmp, status=ios)
#:def strip(PATH_SLASH)
$:"INDEX(tmp, " + PATH_SLASH + ", .true.) + 1" if WIN32 or UNIX else "1"
#:enddef
        this%script_name = tmp(${strip(PATH_SLASH)}$:)
        deallocate (tmp)
!
        if (PRESENT(argparse)) then
          if (argparse) call argparse_(this)
        else
          call argparse_(this)
        end if
      end block
    end if
!
    call timestamp_append(this%times)
!
    if (ALLOCATED(this%results)) then
      block
        integer                        :: n
        type(test_result), allocatable :: tmp(:)
        n = SIZE(this%results)
        allocate (tmp(n + 1))
        if (n > 0) tmp(:n) = this%results(:n)
        tmp(n + 1) = test_result(0, .false.)
        call MOVE_ALLOC(from=tmp, to=this%results)
      end block
    else
      ALLOCATE(this%results(1))
      this%results(1) = test_result(0, .false.)
    end if
!
    if (this%verbose > 0) then
      write (this%dev, '(A)', err=100) SEP2
      write (this%dev, '(A)', err=100) '# Test command :: '//this%script_name
      if (PRESENT(section)) then
        write (this%dev, '(A)', err=100) SEP1
        write (this%dev, '(A)', err=100) '#   Section ----> '//section
      end if
    end if
!
100 return
  end subroutine utest_init
!
  subroutine argparse_(this)
    class(unittest), intent(inout) :: this
    character(:), allocatable      :: argv
    integer                        :: i, narg, length, ios
    argv = ""
    narg = COMMAND_ARGUMENT_COUNT()
    do i = 1, narg
      call GET_COMMAND_ARGUMENT(i, length = length, status=ios)
      if (ios /= 0) cycle
      if (LEN(argv) < length) argv = REPEAT(" ", length)
      call GET_COMMAND_ARGUMENT(i, argv, status=ios)
      if (ios /= 0) cycle
      select case(argv)
      case("--tap")
        this%tap_support = .true.
      end select
    end do
  end subroutine argparse_
!
  subroutine utest_finish(this)
    class(unittest), intent(inout) :: this
    real(RK)                       :: cputime, time
!
    call timestamp_append(this%times)
    time = elappes_time(this%times)
    cputime = elappes_cputime(this%times)
!
    if (n_test(this%results) > 0) then
      write (this%dev, '(A)', err=100) SEP1
      write (this%dev, '(A,I0,A,F9.3,A,F9.3,A)', ADVANCE='NO', err=100)    &
   &  '# Run ', n_test(this%results), ' tests in ', time, ' / ', &
   &  cputime, ' s (sys/cpu)'
      if (n_error(this%results) < 1) then
        write (this%dev, '(A,I0,A,F9.3,A)', err=100) ' ----> Passed'
      else
        write (this%dev, '(A,I0,A)', err=100) NEW_LINE('')//'         ----> ', n_error(this%results), ' error detected.'
      end if
    else
      write (this%dev, '(A)', err=100) '# No Test executed'
    end if
    write (this%dev, '(A)', err=100) SEP2
!
100 FLUSH (this%dev)
    call utest_free(this)
  end subroutine utest_finish
!
  subroutine utest_finish_and_terminate(this)
    class(unittest), intent(inout) :: this
    logical                        :: error_terminate
    error_terminate = this%terminate_with_error_code .and. (COUNT(this%results(:)%err) > 0)
    call this%finish()
    if (error_terminate) then
      call error_stop('TESTS WERE TERMINATED', 1)
    else
      stop
    end if
  end subroutine utest_finish_and_terminate
!
  pure subroutine utest_free(this)
    type(unittest), intent(inout) :: this
    if (ALLOCATED(this%script_name)) deallocate (this%script_name)
    if (ALLOCATED(this%tap_string)) deallocate (this%tap_string)
    if (ALLOCATED(this%times)) deallocate (this%times)
    if (ALLOCATED(this%results)) deallocate (this%results)
    this%terminate_with_error_code = .true.
    this%tap_support = .true.
    this%dump_line_limit = 10
  end subroutine utest_free
!
  subroutine utest_destroy(this)
    type(unittest), intent(inout) :: this
    if (ALLOCATED(this%script_name)) call this%finish()
    call utest_free(this)
  end subroutine utest_destroy
!
! --- private functions
!
  subroutine timestamp_append(times)
    type(timestamp), intent(inout), allocatable :: times(:)
    type(timestamp), allocatable                :: temp(:)
    integer                                      :: n
    if (ALLOCATED(times)) then
      n = SIZE(times)
      allocate (temp(n + 1))
      temp(:n) = times(:)
      call SYSTEM_CLOCK(temp(n + 1)%time)
      call CPU_TIME(temp(n + 1)%ctime)
    else
      allocate (temp(1))
      call SYSTEM_CLOCK(temp(1)%time)
      call CPU_TIME(temp(1)%ctime)
    end if
    call MOVE_ALLOC(from=temp, to=times)
  end subroutine timestamp_append
!
  function elappes_time(times) result(res)
    type(timestamp), intent(in) :: times(:)
    integer(INT64)               :: t_rate, t_max
    real(RK)                     :: res
    integer                      :: n
    call SYSTEM_CLOCK(count_rate=t_rate, count_max=t_max)
    n = SIZE(times)
    if (n > 1) then
      if (times(n)%time < times(n - 1)%time) then
        res = real(t_max + times(n)%time - times(n - 1)%time + 1, RK) / real(t_rate, RK)
      else
        res = real(times(n)%time - times(n - 1)%time, RK) / real(t_rate, RK)
      end if
    else
      res = 0.0_RK
    end if
  end function elappes_time
!
  pure function elappes_cputime(times) result(res)
    type(timestamp), intent(in) :: times(:)
    real(RK)                     :: res
    integer                      :: n
    n = SIZE(times)
    if (n > 1) then
      res = times(n)%ctime - times(n - 1)%ctime
    else
      res = 0.0_RK
    end if
  end function elappes_cputime
!
  pure function n_test(results) result(res)
    type(test_result), intent(in) :: results(:)
    integer                       :: n, res
    n = SIZE(results)
    res = results(n)%id
  end function n_test
!
  pure function n_error(results) result(res)
    type(test_result), intent(in) :: results(:)
    integer                       :: l, u, res
    u = SIZE(results)
    l = u - results(u)%id + 1
    res = COUNT(results(l:u)%err)
  end function n_error
!
end module mod_unittest

