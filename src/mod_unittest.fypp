#:include "common.fypp"
module mod_unittest
  !! Fortran unit testing framework.
  !  This module provides an interface class to the assert method.
  use, intrinsic :: ISO_FORTRAN_ENV, only: STDOUT => OUTPUT_UNIT, &
                  &                        STDERR => ERROR_UNIT, &
                  &                        RK => REAL64
  use mod_unittest_kinds
  implicit none
  private
  public  :: unittest
  public  :: error_stop
!
  character(*), parameter :: SEP1 = REPEAT('-', 64)
  character(*), parameter :: SEP2 = REPEAT('=', 64)
!
  type unittest
    private
    integer                   :: dev
    integer                   :: num_test
    integer                   :: num_error
    integer                   :: verbose
    integer                   :: dump_line_limit
    integer(INT64)            :: start_time
    real(RK)                  :: start_cpu_time
    character(:), allocatable :: script_name
    logical                   :: terminate_with_error_code = .true.
  contains
    procedure         :: init => utest_init
#:for routine in ["assert", "assert_true", "assert_false"]
${generic_procedure(routine, LOGICAL_KIND_TYPE_POSTS, RANK_ITERi)}$
#:endfor
#:for routine in ["assert_equal", "assert_not_equal"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + LOGICAL_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
#:for routine in ["assert_almost_equal", "assert_not_almost_equal"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
#:for routine in ["assert_less", "assert_less_equal", "assert_greater", "assert_greater_equal"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
#:for routine in ["assert_is_eye"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, [(2, None)])}$
#:endfor
#:for routine in ["assert_is_zero", "assert_isnot_zero"]
${generic_procedure(routine, INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, RANK_ITERi)}$
#:endfor
#:for routine in ["assert_allclose", "assert_not_allclose"]
${generic_procedure(routine, REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS, RANK_ITERii)}$
#:endfor
    procedure         :: finish => utest_finish
    procedure         :: finish_and_terminate => utest_finish_and_terminate
    final             :: utest_destroy
  end type unittest
!
  interface unittest
    module procedure :: utest_new
  end interface unittest
!
  interface
    module subroutine error_stop(msg, code)
      character(*), intent(in), optional :: msg
      integer, intent(in), optional      :: code
    end subroutine error_stop
!
#:for routine, cond in zip(["assert", "assert_true", "assert_false"], ["ALL(expr)", "ALL(expr)", ".not.ANY(expr)"])
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERi
    module subroutine ${routine_name(routine, post, rank1)}$ (this, expr, unitname, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: expr${rank_suffix(rank1)}$
      character(*), intent(in), optional :: unitname
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_equal", "assert_not_equal"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + LOGICAL_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERii
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$, b${rank_suffix(rank2)}$
      character(*), intent(in), optional :: unitname
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_almost_equal", "assert_not_almost_equal"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERii
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$, b${rank_suffix(rank2)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:for routine, cond in zip(["assert_less", "assert_less_equal", "assert_greater", "assert_greater_equal"], ["ALL(a<b)", "ALL(a<=b)", "ALL(a>b)", "ALL(a>=b)"])
#:for rank1, rank2 in RANK_ITERii
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$
      ${type}$, intent(in)               :: b${rank_suffix(rank2)}$
      character(*), intent(in), optional :: unitname
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_is_eye"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
    module subroutine ${routine_name(routine, post, 2)}$ (this, a, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(2)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, 2)}$
!
#:endfor
#:endfor
#:for routine in ["assert_is_zero", "assert_isnot_zero"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERi
    module subroutine ${routine_name(routine, post, rank1)}$ (this, a, unitname, place, is_failed)
      class(unittest), intent(inout)     :: this
      ${type}$, intent(in)               :: a${rank_suffix(rank1)}$
      character(*), intent(in), optional :: unitname
      integer, intent(in), optional      :: place
      logical, intent(out), optional     :: is_failed
    end subroutine ${routine_name(routine, post, rank1)}$
!
#:endfor
#:endfor
#:endfor
#:for routine in ["assert_allclose", "assert_not_allclose"]
#:for kind, type, post in REAL_KIND_TYPE_POSTS + COMPLEX_KIND_TYPE_POSTS
#:for rank1, rank2 in RANK_ITERii
    module subroutine ${routine_name(routine, post, rank1, rank2)}$ (this, a, b, unitname, is_failed, rtol, atol)
      class(unittest), intent(inout)       :: this
      ${type}$, intent(in)                 :: a${rank_suffix(rank1)}$
      ${type}$, intent(in)                 :: b${rank_suffix(rank2)}$
      character(*), intent(in), optional   :: unitname
      logical, intent(out), optional       :: is_failed
      real(${kind}$), intent(in), optional :: rtol
      real(${kind}$), intent(in), optional :: atol
    end subroutine ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
  end interface
!
contains
!
  function utest_new(section, terminate_with_error_code) result(res)
    character(*), intent(in), optional :: section
    logical, intent(in), optional      :: terminate_with_error_code
    type(unittest)                     :: res
    call utest_init(res, section, terminate_with_error_code)
  end function utest_new
!
  subroutine utest_init(this, section, terminate_with_error_code, dump_line_limit)
    class(unittest), intent(inout)     :: this
    character(*), intent(in), optional :: section
    logical, intent(in), optional      :: terminate_with_error_code
    integer, intent(in), optional      :: dump_line_limit
    integer                            :: lna, ios
    character(:), allocatable          :: tmp
    call utest_destroy(this)
!
    call CPU_TIME(this%start_cpu_time)
    call SYSTEM_CLOCK(this%start_time)
!
    call GET_COMMAND_ARGUMENT(0, length=lna, status=ios)
    if (ios /= 0) return
!
    this%dev = STDERR
    allocate (character(lna) :: tmp)
    allocate (character(0) :: this%script_name)
    call GET_COMMAND_ARGUMENT(0, value=tmp, status=ios)
    lna = INDEX(tmp, '/', .true.) + 1
    this%script_name = tmp(lna:)
    deallocate (tmp)
!
    write (this%dev, '(A)', err=100) SEP2
    write (this%dev, '(A)', err=100) 'Test command :: '//this%script_name
    if (PRESENT(section)) then
      write (this%dev, '(A)', err=100) SEP1
      write (this%dev, '(A)', err=100) '  Section ----> '//section
    end if
!
    if (PRESENT(terminate_with_error_code)) this%terminate_with_error_code = terminate_with_error_code
    if (PRESENT(dump_line_limit)) this%dump_line_limit = dump_line_limit
    this%verbose = MERGE(1, 0, this%dump_line_limit<0)
!
100 return
  end subroutine utest_init
!
  subroutine utest_finish(this)
    class(unittest), intent(inout) :: this
    integer(INT64)                 :: finish_time, t_rate, t_max
    real(RK)                       :: finish_cpu_time, time
!
    call SYSTEM_CLOCK(finish_time, t_rate, t_max)
    call CPU_TIME(finish_cpu_time)
!
    if (finish_time < this%start_time) then
      time = REAL(t_max - this%start_time + finish_time + 1, RK) / REAL(t_rate, RK)
    else
      time = REAL(finish_time - this%start_time, RK) / REAL(t_rate, RK)
    end if
!
    finish_cpu_time = finish_cpu_time - this%start_cpu_time
!
    if (this%num_test > 0) then
      write (this%dev, '(A)', err=100) SEP1
      write (this%dev, '(A,I0,A,F9.3,A,F9.3,A)', ADVANCE='NO', err=100)    &
   &  ' Run ', this%num_test, ' tests in ', time / DBLE(t_rate), ' / ', &
   &  finish_cpu_time, ' s (sys/cpu)'
      if (this%num_error < 1) then
        write (this%dev, '(A,I0,A,F9.3,A)', err=100) ' ----> Passed'
      else
        write (this%dev, '(A,I0,A)', err=100) NEW_LINE('')//'         ----> ', this%num_error, ' error detected.'
      end if
    else
      write (this%dev, '(A)', err=100) 'No Test executed'
    end if
    write (this%dev, '(A)', err=100) SEP2
!
100 FLUSH (this%dev)
    call utest_free(this)
  end subroutine utest_finish
!
  subroutine utest_finish_and_terminate(this)
    class(unittest), intent(inout) :: this
    logical                        :: error_terminate
    error_terminate = this%terminate_with_error_code .and. (this%num_error > 0)
    call this%finish()
    if (error_terminate) then
      call error_stop('TESTS WERE TERMINATED', 1)
    else
      stop
    end if
  end subroutine utest_finish_and_terminate
!
  pure subroutine utest_free(this)
    type(unittest), intent(inout) :: this
    if (ALLOCATED(this%script_name)) deallocate (this%script_name)
    this%num_test = 0
    this%num_error = 0
    this%terminate_with_error_code = .true.
    this%dump_line_limit = 10
  end subroutine utest_free
!
  subroutine utest_destroy(this)
    type(unittest), intent(inout) :: this
    if (ALLOCATED(this%script_name)) call this%finish()
    call utest_free(this)
  end subroutine utest_destroy
!
end module mod_unittest
