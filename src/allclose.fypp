#:include "common.fypp"
#:set fmts = [REAL_FORMAT, COMPLEX_FORMAT]
#:set ktps = [REAL_KIND_TYPE_POSTS, COMPLEX_KIND_TYPE_POSTS]
#:def erff(s, erf_t)
$:"REAL("+s+", RK)" if erf_t==0 else "REAL(ABS("+s+"), RK)"
#:enddef
#:def error_list_scalar(fm, neq)
      block
        integer  :: ios
        write (this%dev, '(16X,${fm}$)', IOSTAT=ios)  " [", a, "] ${neq}$ [", b, "]"
      end block
#:enddef
#:def error_list_loop(op, rank1, rank2, erf_t, fm, neq)
        block
        integer  :: ${', '.join(["ios, nerror"] + ["i"+str(i) for i in range(1,rank1+1)])}$
        real(RK) :: diff
        if (this%verbose > 0 .or. SIZE(a)<=this%dump_line_limit) then
          nerror = 0
#:for i in range(rank1,0,-1)
          do i${i}$ = 1, SIZE(a, ${i}$)
#:endfor
            diff = ${erff("a" + counter_suffix(rank1) + " - b" + counter_suffix(rank2), erf_t)}$
            if (diff ${op}$ tol) cycle
            nerror = nerror + 1
            write (this%dev, '(*(I6))', IOSTAT=ios, ADVANCE='NO') ${', '.join(["i"+str(i) for i in range(1,rank1+1)])}$
            write (this%dev, '(${fm}$)', IOSTAT=ios)  " [", a${counter_suffix(rank1)}$, "] ${neq}$ [", b${counter_suffix(rank2)}$, "]"
#:for i in range(rank1)
          enddo
#:endfor
        else
          nerror = COUNT([.not.(${erff("a - b", erf_t)}$ ${op}$ tol)])
          call report_error_as_image(this%dev, SIZE(a), MIN(SIZE(a, 1), 50), [${erff("a - b", erf_t)}$])
        end if
        call report_error_rate(this%dev, SIZE(a), nerror)
        end block
#:enddef
submodule(mod_unittest) allclose
  implicit none
contains
#:for ktp, fm, erf_t in zip(ktps, fmts, [0, 1])
#:for kind, type, post in ktp
#:for routine, op, neq, no in zip(["assert_allclose", "assert_not_allclose"], ["<", ">="], ["!~", "~ "], [".not.", ""])
#:for rank1, rank2 in RANK_ITERii
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    real(${kind}$) :: tol
${common_check(rank1, rank2, routine)}$
    if (PRESENT(atol)) then; tol = MAX(atol, 0.0_${kind}$)
    else; tol = 1E-8_${kind}$
    end if
    if (PRESENT(rtol)) then; tol = tol + MAX(rtol, 0.0_${kind}$)
    else; tol = tol + 1E-5_${kind}$ * MAXVAL([ABS(a), ABS(b)])
    end if
    err = ${no}$${"ALL" if rank1>0 else ""}$(ABS(a - b) < tol)
    this%errors = [this%errors, err]
    if (PRESENT(is_failed)) is_failed = err
    call report_result(this%dev, SIZE(this%errors), err, "${routine}$", unitname)
    if (err) then
${error_list_loop(op, rank1, rank2, erf_t, fm, neq) if rank1>0 else error_list_scalar(fm, neq)}$
    end if
    FLUSH (this%dev)
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:endfor
${report_functions()}$
${image_functions()}$
end submodule allclose
