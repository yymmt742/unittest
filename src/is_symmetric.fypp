#:include "common.fypp"
#:set fmts = [INTEGER_FORMAT, REAL_FORMAT, COMPLEX_FORMAT]
#:set ktps = [INTEGER_KIND_TYPE_POSTS, REAL_KIND_TYPE_POSTS, COMPLEX_KIND_TYPE_POSTS]
#:def error_list(fm)
    if (err) then
      block
        integer :: ios, nerror
        nerror = 0
        if (this%verbose > 0 .or. SIZE(a)<=this%dump_line_limit) then
          do j = 1, s2
            do i = j + 1, s1
              diff = ABS(a(i, j) - a(j, i)) * mp
              if (INT(diff) < 1) cycle
              nerror = nerror + 1
              write (this%dev, '(*(I6))', IOSTAT=ios, ADVANCE='NO') i, j
              write (this%dev, '(${fm}$)', IOSTAT=ios) " [", a(i, j), "] !~ [", a(j, i), "]"
            end do
          end do
        else
          block
            real(RK) :: error(s1, s2)
            do j = 1, s2
              do i = 1, s1
                error(i, j) = a(i, j) - a(j, i)
                if (INT(ABS(error(i, j)) * mp) >= 1) nerror = nerror + 1
              end do
            end do
            call report_error_as_image(this%dev, SIZE(a), MIN(SIZE(a, 1), 50), [error])
          end block
        end if
        call report_error_rate(this%dev, SIZE(a), nerror)
      end block
    end if
#:enddef
submodule(mod_unittest) is_symmetric
  implicit none
  integer, parameter :: DEF_PLACE = 7
contains
#:for ktp, fm in zip(ktps, fmts)
#:for kind, type, post in ktp
#:for routine, no in zip(["assert_is_symmetric", "assert_isnot_symmetric"], ["", ".not."])
  module procedure ${routine_name(routine, post, 2)}$
    ${"real(RK)" if "INT" in kind else "real("+kind+")"}$ :: mp, diff
    integer :: i, j, s1, s2
${common_check(2, None, routine)}$
    s1 = SIZE(a, 1)
    s2 = SIZE(a, 2)
    err = s1 /= s2
    if (PRESENT(is_failed)) is_failed = err
    if (err)then
      this%errors = [this%errors, err]
      call report_rank_error(this%dev, SIZE(this%errors), [s1], [s2], unitname)
      return
    endif
    if (PRESENT(place)) then; mp = 10**place
    else; mp = 10**DEF_PLACE
    end if
    do j = 1, s2
      do i = j + 1, s1
        diff = ABS(a(i, j) - a(j, i)) * mp
        err = INT(diff) >= 1
        if(err) exit
      end do
      if(err) exit
    end do
    this%errors = [this%errors, err]
${"!" if no == "" else "    err = .not.err"}$
    if (PRESENT(is_failed)) is_failed = err
    call report_result(this%dev, SIZE(this%errors), err, "${routine}$", unitname)
${error_list(fm) if no == "" else "!"}$
  end procedure ${routine_name(routine, post, 2)}$
!
#:endfor
#:endfor
#:endfor
include "report_functions.f90"
include "image_functions.f90"
end submodule is_symmetric
