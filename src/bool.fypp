#:include "common.fypp"
#:def error_list_scalar(neq)
      block
        integer  :: ios
        write (this%dev, '(8X,A)', IOSTAT=ios) " Assertion Error :: [ ${neq}$ ]"
      end block
#:enddef
#:def error_list_loop(rank, no, neq)
      block
        integer  :: ${', '.join(["ios, nerror"] + ["i"+str(i) for i in range(1,rank+1)])}$
        nerror = 0
#:for i in range(rank,0,-1)
        do i${i}$ = 1, SIZE(expr, ${i}$)
#:endfor
          if (${no}$expr${counter_suffix(rank)}$) cycle
          nerror = nerror + 1
          write (this%dev, '(8X,*(I6))', IOSTAT=ios, ADVANCE='NO') ${', '.join(["i"+str(i) for i in range(1,rank+1)])}$
          write (this%dev, '(A)', IOSTAT=ios) " Assertion Error :: [ ${neq}$ ]"
#:for i in range(rank)
        end do
#:endfor
        call report_error_rate(this%dev, SIZE(expr), nerror)
      end block
#:enddef
submodule(mod_unittest) bool
  implicit none
contains
#:for routine, no, neq in zip(["assert", "assert_true", "assert_false"], [".not.", ".not.", ""], ["failed", "false", "true"])
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
#:for rank in range(MAXIMUM_RANK + 1)
  module procedure ${routine_name(routine, post, rank)}$
${common_check(rank, None, routine)}$
    err = ${no}$${"ALL" if rank>0 else ""}$(expr)
    if (PRESENT(is_failed)) is_failed = err
    call report_result(this%dev, this%num_test, err, "${routine}$", unitname)
    if (err) then
      this%num_error = this%num_error + 1
${error_list_loop(rank, no, neq) if rank>0 else error_list_scalar(neq)}$
    end if
  end procedure ${routine_name(routine, post, rank)}$
!
#:endfor
#:endfor
#:endfor
${report_functions()}$
end submodule bool
