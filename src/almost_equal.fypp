#:include "common.fypp"
#:def error_list_scalar(fm, neq)
      block
        integer  :: ios
        write (this%dev, '(16X,${fm}$)', IOSTAT=ios)  " [", a, "] ${neq}$ [", b, "]"
      end block
#:enddef
#:def error_list_loop(op, rank1, rank2, fm, neq)
      block
        integer  :: ${', '.join(["ios, nerror"] + ["i"+str(i) for i in range(1,rank1+1)])}$
        real(RK) :: diff
        nerror = 0
#:for i in range(rank1,0,-1)
        do i${i}$ = 1, SIZE(a, ${i}$)
#:endfor
          diff = ABS(${"a" + counter_suffix(rank1) + " - b" + counter_suffix(rank2)}$) * mp
          if (INT(diff) ${op}$ 1) cycle
          nerror = nerror + 1
          write (this%dev, '(8X,*(I6))', IOSTAT=ios, ADVANCE='NO') ${', '.join(["i"+str(i) for i in range(1,rank1+1)])}$
          write (this%dev, '(${fm}$)', IOSTAT=ios)  " [", a${counter_suffix(rank1)}$, "] ${neq}$ [", b${counter_suffix(rank2)}$, "]"
#:for i in range(rank1)
        enddo
#:endfor
        call report_error_rate(this%dev, SIZE(a), nerror)
      end block
#:enddef
#:set fmts = ["A,1X,I0,2X,A,1X,I0,2X,A", "A,G16.9,A,G16.9,A", "A,2(ES9.2,1X),A,2(ES9.2,1X),A"]
#:set ktps = [INTEGER_KIND_TYPE_POSTS, REAL_KIND_TYPE_POSTS, COMPLEX_KIND_TYPE_POSTS]
submodule(mod_unittest) almost_equal
  use mod_unittest_printer
  implicit none
  integer, parameter :: DEF_PLACE = 7
contains
#:for ktp, fm in zip(ktps, fmts)
#:for kind, type, post in ktp
#:for routine, op, neq, no in zip(["assert_almost_equal", "assert_not_almost_equal"], ["<", ">="], ["!~", "~ "], [".not.", ""])
#:for rank1, rank2 in RANK_ITERii
  module procedure ${routine_name(routine, post, rank1, rank2)}$
  ${"real(RK)" if "INT" in kind else "real("+kind+")"}$ :: mp
${common_check(rank1, rank2)}$
    if (PRESENT(place)) then; mp = 10**place
    else; mp = 10**DEF_PLACE
    end if
    err = ${no + "ALL(INT(mp * ABS(a - b)) < 1)" if rank1>0 else no + "(mp * ABS(a - b) < 1)"}$
    call report_result(this%dev, this%num_test, err, unitname)
    if (err) then
      this%num_error = this%num_error + 1
${error_list_loop(op, rank1, rank2, fm, neq) if rank1>0 else error_list_scalar(fm, neq)}$
    end if
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:endfor
end submodule almost_equal
