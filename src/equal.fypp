#:include "common.fypp"
submodule(mod_unittest) equal
  use mod_unittest_printer
  implicit none
contains
#:for routine, cond, neq in zip(["assert_equal", "assert_not_equal"], ["a==b", "a/=b"], ["/=", "=="])
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS
  module procedure ${routine_name(routine, post, 0, 0)}$
    logical                        :: err
    integer                        :: ios
      call report_result(this%dev, ${cond}$, unitname, this%num_test, this%num_error, err)
      if (err) write (this%dev, '(2A,I16,A,I16,A)', IOSTAT=ios) AssertionError, ' xxx [', a, '] ${neq}$ [', b, ']'
  end procedure ${routine_name(routine, post, 0, 0)}$

#:endfor
#:endfor
#:for routine, cond, neq in zip(["assert_equal", "assert_not_equal"], ["ALL(a==b)", "ALL(a/=b)"], ["/=", "=="])
#:for rank1, rank2, size in [(0, 1, "SIZE(b)"), (1, 0, "SIZE(a)"), (1, 1, "MIN(SIZE(a), SIZE(b))")]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    logical                        :: err
    integer                        :: i, ios, nerr
      ${rank_check_(rank1, rank2)}$
      call report_result(this%dev, ${cond}$, unitname, this%num_test, this%num_error, err)
      if (err) then
        write (this%dev, '(2A)', IOSTAT=ios) AssertionError, 'LHS ${neq}$ RHS'
        nerr = 0
        do i = 1, ${size}$
          if (a${counter_suffix(rank1)}$ ${neq}$ b${counter_suffix(rank2)}$)then
            nerr = nerr + 1
            write (this%dev, '(6X,i8,A,I16,A,I16,A)', IOSTAT=ios) i, '  xxx [', a${counter_suffix(rank1)}$, '] ${neq}$ [', b${counter_suffix(rank2)}$, ']'
            if (ios > 0) exit
          endif
        end do
        call report_error_rate(this%dev, ${size}$, nerr)
      end if
  end procedure ${routine_name(routine, post, rank1, rank2)}$

#:endfor
#:endfor
#:endfor
#:for routine, cond, neq in zip(["assert_equal", "assert_not_equal"], ["a.eqv.b", "a.neqv.b"], [".neqv.", ".eqv."])
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
  module procedure ${routine_name(routine, post, 0, 0)}$
    logical                        :: err
    integer                        :: ios
      call report_result(this%dev, ${cond}$, unitname, this%num_test, this%num_error, err)
      if (err) write (this%dev, '(2A,I16,A,I16,A)', IOSTAT=ios) AssertionError, ' xxx [', a, '] ${neq}$ [', b, ']'
  end procedure ${routine_name(routine, post, 0, 0)}$

#:endfor
#:endfor
#:for routine, cond, neq in zip(["assert_equal", "assert_not_equal"], ["ALL(a.eqv.b)", ".not.ANY(a.neqv.b)"], [".neqv.", ".eqv."])
#:for rank1, rank2, size in [(0, 1, "SIZE(b)"), (1, 0, "SIZE(a)"), (1, 1, "MIN(SIZE(a), SIZE(b))")]
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    logical                        :: err
    integer                        :: i, ios, nerr
      ${rank_check_(rank1, rank2)}$
      call report_result(this%dev, ${cond}$, unitname, this%num_test, this%num_error, err)
      if (err) then
        write (this%dev, '(2A)', IOSTAT=ios) AssertionError, 'LHS == RHS'
        nerr = 0
        do i = 1, ${size}$
          if (a${counter_suffix(rank1)}$ ${neq}$ b${counter_suffix(rank2)}$)then
            nerr = nerr + 1
            write (this%dev, '(6X,i8,A,I16,A,I16,A)', IOSTAT=ios) i, '  xxx [', a${counter_suffix(rank1)}$, '] ${neq}$ [', b${counter_suffix(rank2)}$, ']'
            if (ios > 0) exit
          endif
        end do
        call report_error_rate(this%dev, ${size}$, nerr)
      end if
  end procedure ${routine_name(routine, post, rank1, rank2)}$

#:endfor
#:endfor
#:endfor
end submodule equal
