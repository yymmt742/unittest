#:include "common.fypp"
submodule(mod_unittest) equal
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS + REAL_KIND_TYPE_POSTS
  use, intrinsic :: ISO_FORTRAN_ENV, only: ${kind}$
#:endfor
  use mod_unittest_printer
  implicit none
contains
#:def error_rate(type)
$:"MERGE(1.0_RK,-1.0_RK,a)" if "logical" in type else "REAL(a - b, RK)"
#:enddef
#:set routines = ["assert_equal", "assert_not_equal"]
#:set ktps = [INTEGER_KIND_TYPE_POSTS, LOGICAL_KIND_TYPE_POSTS]
#:set oplists = [["==", "/="], [".eqv.", ".neqv."]]
#:set neqlists = [["/=", "=="], ["noteq", "equiv"]]
#:set fmts = ["(A,I14,2X,A,I14,2X,A)", "(A,L9,7X,A,L9,7X,A)"]
#:for ktp, oplist, neqlist, fm in zip(ktps, oplists, neqlists, fmts)
#:for kind, type, post in ktp
#:for routine, op, neq in zip(routines, oplist, neqlist)
#:for rank2 in [0, 1]
#:for rank1 in [0, 1]
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    logical :: err
${rank_check(rank1, rank2)}$
    call check_expr_all(this%dev, this%num_test, ${flatten(routine+"_"+post+"(a,b)", rank1, rank2)}$, &
   &                    unitname, this%num_error, err)
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
  pure elemental function ${routine}$_${post}$(a, b) result(res)
    ${type}$, intent(in) :: a, b
    type(expr_report) :: res
    res%ok = a ${op}$ b
    if(res%ok)then
      res%msg = ""
      res%error_rate = 0.0_RK
    else
      write(res%msg, '${fm}$') "[", a, "]${neq}$[", b, "]"
      res%error_rate = ${error_rate(type)}$
    endif
  end function ${routine}$_${post}$
!
#:endfor
#:endfor
#:endfor
end submodule equal
