#:include "common.fypp"
#:set routines = ["equal", "not_equal"]
#:set ktps = [INTEGER_KIND_TYPE_POSTS, LOGICAL_KIND_TYPE_POSTS]
#:set fmts = [INTEGER_FORMAT, LOGICAL_FORMAT]
#:def error_rate(type, no)
$:"MERGE(MERGE(1.0_RK,-1.0_RK,a), 0.0_RK, "+no+"a.eqv.b)" if "logical" in type else "MERGE(1.0_RK, 0.0_RK, "+no+"(a==b))"
#:enddef
#:def error_list_scalar(fm, neq)
      block
        integer  :: ios
        write (this%dev, '(8X,${fm}$)', IOSTAT=ios)  " [", a, "] ${neq}$ [", b, "]"
        write (this%dev, '(A)', IOSTAT=ios) ${SEP3}$
      end block
#:enddef
#:def error_list_loop(op, rank1, rank2, fm, no, neq, type)
      block
        integer  :: ${', '.join(["ios, nerror"] + ["i"+str(i) for i in range(1,rank1+1)])}$
        if (this%verbose > 0 .or. SIZE(a)<=this%dump_line_limit) then
          nerror = 0
${do_start(rank1)}$
            if (${no}$a${counter_suffix(rank1)}$${op}$b${counter_suffix(rank2)}$) then
              nerror = nerror + 1
              write (this%dev, '(9X,*(I0,1X))', IOSTAT=ios, ADVANCE='NO') ${', '.join(["i"+str(i) for i in range(1,rank1+1)])}$
             write (this%dev, '(${fm}$)', IOSTAT=ios) " [", a${counter_suffix(rank1)}$, " ${neq}$ ", b${counter_suffix(rank2)}$, "]"
            end if
${do_end(rank1)}$
        else
          nerror = COUNT([${no}$(a ${op}$ b)])
          call report_error_as_image(this%dev, SIZE(a), MIN(SIZE(a, 1), 50), [${error_rate(type, no)}$])
        end if
        call report_error_rate(this%dev, SIZE(a), nerror)
      end block
#:enddef
submodule(mod_unittest) equal
  implicit none
contains
#:for ktp, op, fm in zip(ktps, ["==", ".eqv."], fmts)
#:for kind, type, post in ktp
#:for routine, no in zip(routines, [".not.", ""])
#:for rank1, rank2 in RANK_ITERii
  module procedure ${routine_name(routine, post, rank1, rank2)}$
${common_check(rank1, rank2, routine)}$
    err = ${no}$${"ALL" if rank1>0 else ""}$(a ${op}$ b)
    call test_result_append(this%results, err)
    if (PRESENT(is_failed)) is_failed = err
    call report_result(this%dev, this%results(SIZE(this%results))%id, err, "${routine}$", unitname)
    if (err) then
${error_list_loop(op, rank1, rank2, fm, no, strnop(op), type) if rank1>0 else error_list_scalar(fm, strnop(op))}$
    end if
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:endfor
include "result_functions.f90"
include "report_functions.f90"
include "image_functions.f90"
end submodule equal
