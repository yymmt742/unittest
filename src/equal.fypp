#:include "common.fypp"
submodule(mod_unittest) equal
  use mod_unittest_printer
  implicit none
contains
#:set routines = ["assert_equal", "assert_not_equal"]
#:for kind, type, post in INTEGER_KIND_TYPE_POSTS
#:for routine, expr, neq in zip(routines, ["a==b", "a/=b"], ["/=", "=="])
#:for rank2 in [0, 1]
#:for rank1 in [0, 1]
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    logical :: err
${rank_check(rank1, rank2)}$
    call check_expr_all(this%dev, this%num_test, [${expr}$], unitname, this%num_error, err)
    if (err) call report_summary(this%dev, [${expr}$], [${post}$_error_rate(a, b)])
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
  pure elemental function ${post}$_error_rate(a, b) result(res)
    use, intrinsic :: ISO_FORTRAN_ENV, only: ${kind}$
    ${type}$, intent(in) :: a, b
    real(RK)             :: res
    res = ABS(a - b)
  end function ${post}$_error_rate
!---------------------------------------------------------------------
#:endfor
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
#:for routine, expr, neq in zip(routines, ["a.eqv.b", "a.neqv.b"], [".neqv.", ".eqv."])
#:for rank2 in [0, 1]
#:for rank1 in [0, 1]
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    logical :: err
${rank_check(rank1, rank2)}$
    call check_expr_all(this%dev, this%num_test, [${expr}$], unitname, this%num_error, err)
    if (err) call report_summary(this%dev, [${expr}$], [MERGE(0.0_RK, 1.0_RK, ${expr}$)])
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
#:endfor
#:endfor
#:endfor
end submodule equal
