#:include "common.fypp"
submodule(mod_unittest) compare
  use mod_unittest_printer
  implicit none
contains
#:set ktps = [INTEGER_KIND_TYPE_POSTS, REAL_KIND_TYPE_POSTS]
#:set fmts = ["(A,I14,2X,A,I14,2X,A)", "(A,G16.9,A,G16.9,A)"]
#:set routines = ["assert_less", "assert_less_equal", "assert_greater", "assert_greater_equal"]
#:set ops = ["<", "<=", ">", ">="]
#:set neqs = [">=", "> ", "<=", "< "]
#:for ktp, fm in zip(ktps, fmts)
#:for kind, type, post in ktp
#:for routine, op, neq, rate in zip(routines, ops, neqs, ["a - b", "a - b", "b - a", "b - a"])
#:for rank1, rank2 in RANK_ITERii
  module procedure ${routine_name(routine, post, rank1, rank2)}$
    logical :: err
${rank_check(rank1, rank2)}$
    call check_expr_all(this%dev, this%num_test, ${flatten(routine+"_"+post+"(a, b)", rank1, rank2)}$,&
   &                    unitname, this%num_error, err)
  end procedure ${routine_name(routine, post, rank1, rank2)}$
!
#:endfor
  pure elemental function ${routine}$_${post}$(a, b) result(res)
    ${type}$, intent(in) :: a, b
    type(expr_report)             :: res
    res%ok = a ${op}$ b
    if(res%ok) then
      res%msg = ""
      res%error_rate = 0.0_RK
    else
      write(res%msg, '${fm}$') "[", a, "]${neq}$[", b, "]"
      res%error_rate = ${rate}$
    end if
  end function ${routine}$_${post}$
!
#:endfor
#:endfor
#:endfor
end submodule compare
