#:mute

#:set INTEGER_KINDS = ["INT8", "INT16", "INT32", "INT64"]
#:set INTEGER_POSTFIX = ["i8", "i16", "i32", "i64"]
#:set REAL_KINDS = ["REAL32", "REAL64", "REAL128"]
#:set REAL_POSTFIX = ["r32", "r64", "r128"]
#:set COMPLEX_POSTFIX = ["c32", "c64", "c128"]
#:set LOGICAL_KINDS = [""]
#:set LOGICAL_TYPES = ["logical"]
#:set LOGICAL_POSTFIX = ["logical"]

#:set INTEGER_TYPES = [f"integer({k})" for k in INTEGER_KINDS]
#:set REAL_TYPES = [f"real({k})" for k in REAL_KINDS]
#:set COMPLEX_TYPES = [f"complex({k})" for k in REAL_KINDS]
#:set LOGICAL_TYPES = [f"logical"]

#:set INTEGER_KIND_TYPE_POSTS = list(zip(INTEGER_KINDS, INTEGER_TYPES, INTEGER_POSTFIX))
#:set REAL_KIND_TYPE_POSTS = list(zip(REAL_KINDS, REAL_TYPES, REAL_POSTFIX))
#:set COMPLEX_KIND_TYPE_POSTS = list(zip(REAL_KINDS, COMPLEX_TYPES, COMPLEX_POSTFIX))
#:set LOGICAL_KIND_TYPE_POSTS = list(zip(LOGICAL_KINDS, LOGICAL_TYPES, LOGICAL_POSTFIX))

#:set COUNTER_VAR = ["i", "j", "k", "l", "m", "n"]

#:def decimal_suffix(type)
#{if 'REAL' in type}#.0#{endif}#
#:enddef

#:def routine_name(g, post, rank1, rank2=None)
$:f"unittest_{g}_{post}_{rank1}" if rank2 is None else f"unittest_{g}_{post}_{rank1}{rank2}"
#:enddef

#:def rank_suffix(rank)
#{if rank>0}#(${",".join([":" for i in range(rank)])}$)#{endif}#
#:enddef

#:def counter_suffix(rank)
#{if rank>0}#(${",".join(COUNTER_VAR[:rank])}$)#{endif}#
#:enddef

#:def generic_procedure(g, tup, rank1, rank2=None)
#:for kind, type, post in tup
  procedure, private :: ${routine_name(g, post, rank1, rank2)}$
#:endfor
  generic            :: ${g}$  => &
  ${", &\n  ".join(["                      " + routine_name(g, post, rank1, rank2) for kind, type, post in tup])}$
#:enddef

#:endmute
