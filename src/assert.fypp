#:include "common.fypp"
submodule(mod_unittest) bool
  use mod_unittest_printer
  implicit none
contains
#:for routine, cond in zip(["assert", "assert_true", "assert_false"], ["expr", "expr", ".not.expr"])
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
  module procedure ${routine_name(routine, post, 0)}$
    logical                        :: err
    integer                        :: ios
      call report_result(this%dev, ${cond}$, unitname, this%num_test, this%num_error, err)
      if (err) write (this%dev, '(2A)', IOSTAT=ios) AssertionError, ' xxx ASSERT ERROR'
  end procedure ${routine_name(routine, post, 0)}$

#:endfor
#:endfor
#:for routine, cond in zip(["assert", "assert_true", "assert_false"], ["ALL(expr)", "ALL(expr)", ".not.ANY(expr)"])
#:for rank in [1]
#:for kind, type, post in LOGICAL_KIND_TYPE_POSTS
  module procedure ${routine_name(routine, post, rank)}$
    logical                        :: err
    integer                        :: i, ios, nerr
      call report_result(this%dev, ${cond}$, unitname, this%num_test, this%num_error, err)
      if (err) then
        write (this%dev, '(2A)', IOSTAT=ios) AssertionError, 'ASSERT 1D'
        nerr = 0
        do i = 1, SIZE(expr)
          if (.not. expr(i)) cycle; nerr = nerr + 1
          write (this%dev, '(6X,i8,A)', IOSTAT=ios) i, '  xxx error'
          if (ios > 0) exit
        end do
        call report_error_rate(this%dev, SIZE(expr), nerr)
      end if
  end procedure ${routine_name(routine, post, rank)}$

#:endfor
#:endfor
#:endfor
end submodule bool
